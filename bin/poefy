#!/usr/bin/env ruby
# Encoding: UTF-8

################################################################################
# Use Poefy::PoefyGen to make a poem from the command line.
################################################################################

require 'optparse'

require_relative '../lib/poefy.rb'

# Attempt to load exactly one of the below files.
# Array is ordered by priority, so use PostgreSQL before SQLite.
# ToDo: Replace with 'poefy/pg' and 'poefy/sqlite3'
loaded_file = nil
[
  '../lib/poefy/pg.rb',
  '../lib/poefy/sqlite3.rb'
].each do |file|
  begin
    require_relative file
    loaded_file = file
    break
  rescue LoadError
  end
end

# Exit and send error to the console if no file loaded.
if loaded_file.nil?
  msg = "ERROR: Please specify the type of database to use." +
      "\n       The 'poefy' gem does not implement a database interface" +
      "\n       by default; you must install one of the below gems:" +
      "\n         gem install poefy-sqlite3" +
      "\n         gem install poefy-pg"
  STDERR.puts msg
  exit 1
end

################################################################################

def parse_options
  options = { console: true }

  # Set up variables used later.
  forms = Poefy.poetic_forms
  forms_by_4 = forms.each_slice(4).to_a.map { |i| i.join ', ' }
  rhyme_docs = "    This is the most important argument.
      All other form strings are based on this.
    Each token represents a line.
      (Token examples: 'a', 'b', 'A1', ' ')
    Letters indicate rhymes, so all 'a' or 'A' lines have the same rhyme.
      (Example, limerick: 'aabba')
    Uppercase letter lines will be duplicated exactly.
      This is used to create refrain lines.
      (Example, rondeau: 'aabba aabR aabbaR')
    Numbers after a capital letter indicate which specific line to repeat.
      (Example, villanelle: 'A1bA2 abA1 abA2 abA1 abA2 abA1A2'"

  # Get all of the command-line options.
  optparse = OptionParser.new do |opts|

    # Set a banner, displayed at the top of the help screen.
    program_info = %[      Poefy, Line-Based Poem Generator
      Version #{Poefy.version_number} - #{Poefy.version_date}
      https://github.com/nossidge/poefy
      Paul Thompson - nossidge@gmail.com
    ].gsub('      ','  ')

    usage = %[Usage: poefy shakespeare -m < shakespeare_sonnets.txt
      poefy shakespeare sonnet
      poefy spoke haiku
      poefy therese -r 'abab cdcd efef gg' -i '0101 0101 0011 01'
      poefy whitman -r 'A1bA2 abA1 abA2 abA1 abA2 abA1A2'
    ].gsub('      ','       ')

    corpora = (Poefy::Database.list)
               .each_slice(4).to_a
               .map { |i| i.join ', ' }
               .join("\n" + ' ' * 21)
    corpora = 'Corpora available: ' + corpora

    opts.banner = program_info + "\n" + usage + "\n" + corpora + "\n\n"

    # These will be further validated within the class.
    opts.on('-f', '--form STRING',
            "A named poetic form for the output\n" +
            ' ' * 37 + "Specifies rhyme, indent and syllable\n" +
            ' ' * 37 + "One of:\n" +
            ' ' * 39 + forms_by_4.join("\n" + ' ' * 39)) do |s|
      options[:form] = s
    end
    opts.on('-r', '--rhyme STRING', "(See 'Description of rhyme string' below)") do |s|
      options[:rhyme] = s
    end
    opts.on('-i', '--indent STRING', "Indentation of each line") do |s|
      options[:indent] = s
    end
    opts.on('-s', '--syllable STRING',
                  "Apply syllable constraints to certain lines") do |s|
      options[:syllable] = s
    end
    opts.on('-x', '--regex STRING',
                  "Apply regex constraints to certain lines") do |s|
      options[:regex] = s
    end

    # Options for acrostic poems.
    opts.on('-a', '--acrostic STRING',
            "Generate an acrostic on a certain word") do |s|
      options[:acrostic] = s
    end
    opts.on('-A', '--acrostic_x STRING',
            "Generate an acrostic with better handling of 'x'") do |s|
      options[:acrostic_x] = s
    end

    # Handle proper sentence structure.
    opts.separator nil
    opts.on('-p', '--proper',
            "Ensure first word is not 'and but or nor yet'\n" +
            ' ' * 39 + "and final line ends with closing punctuation'\n" +
            ' ' * 39 + "Defaults to ON -- Use this option to DISABLE") do
      options[:proper] = false
    end

    # Repeat options.
    opts.separator nil
    opts.on('-n', '--number INTEGER',
            "Number of poems to generate") do |n|
      options[:number] = n.to_i
    end

    # Corpus options.
    opts.separator nil
    opts.on('-m', '--make [STRING]',
            "Make new or overwrite existing corpus with piped input\n" + ' ' * 39 +
            "Argument is a description of the corpus") do |s|
      options[:make_corpus] = true
      options[:corpus_desc] = s
    end
    opts.on('-d', '--desc STRING',
            "Overwrite the description of the corpus") do |s|
      options[:corpus_desc] = s
    end
    opts.on('-L', '--list',
            "List all the installed corpora") do
      puts Poefy::Database.list
      exit 0
    end
    opts.on('-l', '--local',
            "(SQLite only) Default is to use database files from /data/\n" + ' ' * 39 +
            "With this option, paths are relative to working directory") do
      options[:local] = true
    end

    # Help output.
    opts.separator nil
    opts.on('-h', '--help', 'Display this help screen' ) do
      puts opts
      exit 0
    end
    opts.on('-v', '--version', 'Display the version number' ) do
      puts "poefy #{Poefy.version_number} (#{Poefy.version_date})"
      exit 0
    end

    opts.separator nil
    opts.separator "Description of rhyme string:"
    opts.separator rhyme_docs
    opts.separator nil
    opts.separator "All of this is much better documented in README.md"
  end

  # Parse the options and show errors on failure.
  begin
    optparse.parse! ARGV
  rescue OptionParser::ParseError => e
    puts e
    exit 1
  end

  options
end

################################################################################

# Parse the options to shift the ARGV list.
options = parse_options

# Read data lines from STDIN.
data = (not STDIN.tty? and not STDIN.closed?) ? STDIN.read : nil

# Corpus name is the first argument.
first_arg = ARGV.first
if first_arg.nil?
  STDERR.puts "ERROR: Please specify a corpus name to read from/to"
  exit 1
end

# If the first argument is 'make_dbs', then make corpora
#   from the text files included in the main repo.
if first_arg == 'make_dbs'

  # Exclude all lines which do not contain lowercase letters.
  make_db = proc do |database, textfile, description|
    file  = Poefy.root + '/data/' + textfile
    input = File.readlines(file).keep_if { |i| i =~ /[a-z]/ }
    poefy = Poefy::PoefyGen.new database
    poefy.make_database! input, description
  end
  [
    [
      'shakespeare',
      'shakespeare_sonnets.txt',
      "Shakespeare's sonnets"
    ],[
      'therese',
      'st_therese_of_lisieux.txt',
      "St. Thérèse of Lisieux"
    ],[
      'whitman',
      'whitman_leaves.txt',
      "Walt Whitman, Leaves of Grass"
    ],[
      'dickinson',
      'emily_dickinson.txt',
      "Emily Dickinson"
    ],[
      'spoke',
      'english_as_she_is_spoke.txt',
      "English As She Is Spoke"
    ]
  ].each do |i|
    make_db.call *i
  end

  exit 0
end

# Poetic form name is the second argument, if it exists.
second_arg = (ARGV.length > 1) ? ARGV[1] : ''
options[:form] = second_arg if second_arg != ''

# If we need to make a corpus.
# Exit the program after corpus is generated.
if options[:make_corpus]
  poefy = Poefy::PoefyGen.new first_arg
  if data
    poefy.make_database data, options[:corpus_desc], true
    poefy.close
    exit 0
  else
    STDERR.puts 'ERROR: Need text input to generate a corpus'
    STDERR.puts '       Please pipe some data into the program'
    exit 1
  end
end

# If we need to update a corpus description.
# Exit the program after corpus is generated.
if options[:corpus_desc]
  poefy = Poefy::PoefyGen.new first_arg
  begin
    poefy.db.desc = options[:corpus_desc]
    poefy.close
    exit 0
  rescue
    STDERR.puts "ERROR: Corpus '#{first_arg}' does not yet exist"
    exit 1
  end
end

# If the second argument is 'rhyme', then output all
#   lines that rhyme with the word.
if second_arg == 'rhyme'
  poefy = Poefy::PoefyGen.new first_arg
  third_arg  = (ARGV.length > 2) ? ARGV[2] : nil
  fourth_arg = (ARGV.length > 3) ? ARGV[3] : nil
  puts poefy.rhymes(third_arg, fourth_arg)
  exit 0
end

# If there is piped data, or the second argument is a file,
#   then use that as the poetic_form.
if data or File.exists?(second_arg)
  options[:form_from_text] = (data || second_arg)
end

# Create poefy object using the options.
poefy = Poefy::PoefyGen.new first_arg, options

# Make the correct number of poems, and output them.
number = options[:number] || 1
number.times do |i|
  poem = poefy.poem
  if poem
    puts poem
    puts nil if i < number - 1
  end
end

# Close the database connection.
poefy.close

################################################################################
